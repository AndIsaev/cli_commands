# My cli commands guide 

### команда показываюая доступные команды в оболочке
```shell
ls /bin
```
### команда показывающая все ключевые слова в оболочке
```shell
compgen -k
```
### команда которая пытается создать в каталоге путь с игнорированием ошибок
```shell
mkdir -p /tmp/test/kek
```
### команда позволяющая дописывать информацию в файл, а не перезаписывать его
```shell
ls /bin >> test.out
```
### команда позволяющая видеть исполнение и одновременно записывать в файл
```shell
ls /bin > test.out | tee
```
### команда ping  с ограничением
```shell
ping -c 10
```
### команда с запуском в фоновом режиме без записи в файл
```shell
ping 192.168.10.56 -c 10 > dev/null &
```
### команда с запуском в фоновом режиме с записью в файл
```shell
ping 192.168.10.56 > ping.log &
```
### команда для просмотра работающих команд в фоне
```shell
jobs
```
чтобы вывести из фонового режима `fg`
чтобы ввести обратно в фоновый режим `bg`
### команда для подстановки переменной в текст, важно использовать 2-е кавычки
```shell
MY_ITEM2=case
MY_ITEM="test $MY_ITEM2"
echo $MY_ITEM
```
### для записи результата команды в переменную используется следующая команда
```shell
CMDOUT=$(pwd)
```
### для вывода параметров команды используется обращение 
```shell
  $# - количество параметров
  #0 - название скрипта
  #1 и тд - параметр

пример 
echoparams.sh
#!/bin/bash -
#
# Bash и кибербезопасность
# echoparams.sh
#
# Описание:
# Демонстрация доступа к параметрам в bash
#
# Использование:
# ./echoparms.sh <param 1> <param 2> <param 3>
#
echo $#
echo $0
echo $1
echo $2
echo $3

выведет
$ ./echoparams.sh bash is fun
3
./echoparams.sh
bash
is
fun
```
### Чтобы проверить существует ли файл в файловой сиситеме есть команда
```shell
if [[ -e $FILENAME ]]
then
echo $FILENAME exists
fi
---------
-d Проверка, существует ли каталог
-e Проверка, существует ли файл
-r Проверка, существует ли файл и доступен ли он для чтения
-w Проверка, существует ли файл и доступен ли он для записи
-x Проверка, существует ли файл и является ли он
исполняемым
----
```
### Для проверки что VAL_1 меньше VAL_2 можно использовать следующее выражение
```shell
VAL_1=1
VAL_2=2
if [[ $VAL_1 -lt $VAL_2 ]]
then
echo "value $VAL_1 less than $VAL_2"
fi
```

| Тест на равенство между числами      | Проверка, больше ли одно число, чем другое       | Проверка, меньше ли одно число, чем другое |
|:-------------------------------------|:-------------------------------------------------|:-------------------------------------------|
| `-eq`                                     | `-gt`                                                 | `-lt`                                           |
### Если вы хотите выполнить численное сравнение со знаком «меньше», используйте конструкцию с двойными скобками. Предполагается, что все переменные являются числовыми, поэтому они так и будут оцениваться. Пустые или неустановленные переменные оцениваются как 0. Внутри скобок вам не нужен оператор `$` для получения значения, за исключением позиционных параметров, таких как `$1` и `$2` (чтобы не путать их с константами 1 и 2) 
```shell
VAL=1
if (( VAL < 12 ))
then
echo "value $VAL is too small"
fi
```
### Вы можете использовать синтаксис [[ для выполнения различных тестов, даже без задания в явном виде if
```shell
[[ -d $DIR ]] && ls "$DIR"
```
Это работает так же, как если бы вы написали следующее:
```shell
if [[ -d $DIR ]]
then
ls "$DIR"
fi
```
### Простой цикл `while`
```shell
i=0
while (( i < 1000 ))
do
   echo $i
   let i++
done
```
### Простой цикл `for`
```shell
for ((i=0; i < 100; i++))
do
echo $i
done
```
### Цикл `for` с использованием аргументов
`args.sh`
```
for ARG
do
echo here is an argument: $ARG
done
```
```shell
./for/args.sh bash is fun
```
```
here is an argument: bash
here is an argument: is
here is an argument: fun
```
### Простой цикл `for` с итерацией по массиву
```shell
for val in {0..100} ; do echo $val ; done
```
### Важно понимать что фигурный скобки имеют следующий синтаксис
```
{first..last..step}
где ..step может быть положительным
или отрицательным и является опциональным
```
```shell
echo {2..10..2}
```
выведет
`2 4 6 8 10
`

обратный счет
```shell
echo {10..0}
```
`
выведет 10 9 8 7 6 5 4 3 2 1 0
`

### Функции
```
Синтаксис функции в bash следующий:
function myfun ()
{
# это тело функции
}
______________________
В определении функции параметры не объявляются. Какие бы аргументы
и их количество при вызове функции ни приводились, они передаются этой
функции.
______________________
1) определение:
function myfun ()
{
echo $1 $2
}

2) вызов:
myfun 2 /arb "14 years"

3) вывод:
2 /arb
```

### Скрипт для определения os
```shell
bash scripts/detect_os.sh
```

### Получить информацию о текщей машине и ос
```shell
uname -a
```

## Регилярные выражения
### Команда `grep` 

ищет строки, соответствующие заданному шаблону, в файлах или выводе команд.

`grep "шаблон" файл`

| Флаг          | Описание                                                                                                 |
|:--------------|:---------------------------------------------------------------------------------------------------------|
| `-i`          | `игнорировать регистр`                                                                                   |
| `-v`          | `вывести только строки, не содержащие шаблон`                                                            |
| `-r`, `-R`    | `рекурсивный поиск во вложенных папках`                                                                  |
| `-n`          | `показывать номер строки`                                                                                |
| `-c`          | `вывести количество строк, соответствующих шаблону`                                                      |
| `-l`          | `вывести только имя файла и путь, по которому был найден шаблон`                                         |
| `-E`, `egrep` | `включить расширенное регулярное выражение`                                         |

например поиск слова `password` в каталоге `home` и во всех его подкаталогах файлов
```shell
grep -R -i 'password' /home
```
### `Метасимвол «.»`

В регулярном выражении точка (.) представляет собой один символ подстановки.
Т.е. если мы хотим в тексте отыскать слово `Two` в файле `frost.txt` то нужно авполнить команду:
```shell
grep 'T.o' frost.txt
```
```text
1 Two roads diverged in a yellow wood,
```
Данный шаблон позволяет любому символу появляться между символами `T и o`, между символами `T и o` должен находиться еще один символ
(это обозначается символом подстановки в виде точки).

Шаблоны регулярных выражений также `чувствительны к регистру`, поэтому строка 3 файла не возвращается, хотя она содержит слово too.
Без учета регистра
```shell
grep -i 'T.o' frost.txt
```
```text
1 Two roads diverged in a yellow wood,
3 And be one traveler, long I stood
```
Если вы хотите трактовать этот метасимвол как символ точки, а не как символ подстановки, то добавьте перед ним обратный
слеш `(\.)`.

### `Метасимвол «?»`
В регулярном выражении знак вопроса (?) делает любой предшествующий ему
символ необязательным

```shell
egrep 'T.?o' frost.txt
```
или
```shell
grep -E 'T.?o' frost.txt
```
```text
1 Two roads diverged in a yellow wood,
5 To where it bent in the undergrowth;
```
На этот раз мы получим две строки: 1 и 5. Это потому, что метасимвол `.` стал
необязательным, так как за ним стоит метасимвол `?`.
Данный шаблон будет соответствовать любой трехсимвольной последовательности, которая начинается с `T`
и заканчивается `o`, а также двухсимвольной последовательности `To`.

### `Метасимвол «*»`
В регулярных выражениях звездочка (*) — это специальный символ, который соответствует предыдущему элементу неограниченное количество раз. Он похож на
символ ?, но главное отличие в том, что предыдущий элемент может встречаться
более одного раза. Вот пример:
```shell
grep 'T.*o' frost.txt
```
```text
1 Two roads diverged in a yellow wood,
5 To where it bent in the undergrowth;
7 Excerpt from The Road Not Taken by Robert Frost
```
Добавив метасимвол `.*` в предыдущем шаблоне, мы подразумеваем, что между
символами `T` и `o` может быть любое количество любых символов. Следовательно,
после выполнения заданной команды результатом станет и последняя строка, содержащая набор символов `The Ro`.
