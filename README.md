# My cli commands guide 

### команда показываюая доступные команды в оболочке
```shell
ls /bin
```
### команда показывающая все ключевые слова в оболочке
```shell
compgen -k
```
### команда которая пытается создать в каталоге путь с игнорированием ошибок
```shell
mkdir -p /tmp/test/kek
```
### команда позволяющая дописывать информацию в файл, а не перезаписывать его
```shell
ls /bin >> test.out
```
### команда позволяющая видеть исполнение и одновременно записывать в файл
```shell
ls /bin > test.out | tee
```
### команда ping  с ограничением
```shell
ping -c 10
```
### команда с запуском в фоновом режиме без записи в файл
```shell
ping 192.168.10.56 -c 10 > dev/null &
```
### команда с запуском в фоновом режиме с записью в файл
```shell
ping 192.168.10.56 > ping.log &
```
### команда для просмотра работающих команд в фоне
```shell
jobs
```
чтобы вывести из фонового режима `fg`
чтобы ввести обратно в фоновый режим `bg`
### команда для подстановки переменной в текст, важно использовать 2-е кавычки
```shell
MY_ITEM2=case
MY_ITEM="test $MY_ITEM2"
echo $MY_ITEM
```
### для записи результата команды в переменную используется следующая команда
```shell
CMDOUT=$(pwd)
```
### для вывода параметров команды используется обращение 
```shell
  $# - количество параметров
  #0 - название скрипта
  #1 и тд - параметр

пример 
echoparams.sh
#!/bin/bash -
#
# Bash и кибербезопасность
# echoparams.sh
#
# Описание:
# Демонстрация доступа к параметрам в bash
#
# Использование:
# ./echoparms.sh <param 1> <param 2> <param 3>
#
echo $#
echo $0
echo $1
echo $2
echo $3

выведет
$ ./echoparams.sh bash is fun
3
./echoparams.sh
bash
is
fun
```
### Чтобы проверить существует ли файл в файловой сиситеме есть команда
```shell
if [[ -e $FILENAME ]]
then
echo $FILENAME exists
fi
---------
-d Проверка, существует ли каталог
-e Проверка, существует ли файл
-r Проверка, существует ли файл и доступен ли он для чтения
-w Проверка, существует ли файл и доступен ли он для записи
-x Проверка, существует ли файл и является ли он
исполняемым
----
```
### Для проверки что VAL_1 меньше VAL_2 можно использовать следующее выражение
```shell
VAL_1=1
VAL_2=2
if [[ $VAL_1 -lt $VAL_2 ]]
then
echo "value $VAL_1 less than $VAL_2"
fi
```

| Тест на равенство между числами      | Проверка, больше ли одно число, чем другое       | Проверка, меньше ли одно число, чем другое |
|:-------------------------------------|:-------------------------------------------------|:-------------------------------------------|
| `-eq`                                     | `-gt`                                                 | `-lt`                                           |
### Если вы хотите выполнить численное сравнение со знаком «меньше», используйте конструкцию с двойными скобками. Предполагается, что все переменные являются числовыми, поэтому они так и будут оцениваться. Пустые или неустановленные переменные оцениваются как 0. Внутри скобок вам не нужен оператор `$` для получения значения, за исключением позиционных параметров, таких как `$1` и `$2` (чтобы не путать их с константами 1 и 2) 
```shell
VAL=1
if (( VAL < 12 ))
then
echo "value $VAL is too small"
fi
```
### Вы можете использовать синтаксис [[ для выполнения различных тестов, даже без задания в явном виде if
```shell
[[ -d $DIR ]] && ls "$DIR"
```
Это работает так же, как если бы вы написали следующее:
```shell
if [[ -d $DIR ]]
then
ls "$DIR"
fi
```
### Простой цикл `while`
```shell
i=0
while (( i < 1000 ))
do
   echo $i
   let i++
done
```
### Простой цикл `for`
```shell
for ((i=0; i < 100; i++))
do
echo $i
done
```
### Цикл `for` с использованием аргументов
`args.sh`
```
for ARG
do
echo here is an argument: $ARG
done
```
```shell
./for/args.sh bash is fun
```
```
here is an argument: bash
here is an argument: is
here is an argument: fun
```
### Простой цикл `for` с итерацией по массиву
```shell
for val in {0..100} ; do echo $val ; done
```
### Важно понимать что фигурный скобки имеют следующий синтаксис
```
{first..last..step}
где ..step может быть положительным
или отрицательным и является опциональным
```
```shell
echo {2..10..2}
```
выведет
`2 4 6 8 10
`

обратный счет
```shell
echo {10..0}
```
`
выведет 10 9 8 7 6 5 4 3 2 1 0
`

### Функции
```
Синтаксис функции в bash следующий:
function myfun ()
{
# это тело функции
}
______________________
В определении функции параметры не объявляются. Какие бы аргументы
и их количество при вызове функции ни приводились, они передаются этой
функции.
______________________
1) определение:
function myfun ()
{
echo $1 $2
}

2) вызов:
myfun 2 /arb "14 years"

3) вывод:
2 /arb
```

### Скрипт для определения os
```shell
bash scripts/detect_os.sh
```